The TCPR home page, <http://www.cs.cornell.edu/~burgess/tcpr/>, provides
information about the people involved in the project, the code development
repository, and TCPR's design and ongoing research.  This document aims
to guide someone new to the project from first cloning the code repository
through conducting a live demonstration and developing new applications.

TCPR uses the GNU autotools build system.  However, the repository does
not contain any generated files, so once, right after cloning, you must
set up some infrastructure:

  $ autoreconf -i

The filter depends on the `libnfnetlink' and `libnetfilter_queue'
libraries and development headers, which can be installed on an Ubuntu
machine with:

  # apt-get install libnetfilter-queue-dev

The following examples also assume you have some common system
administration utilities installed:

  # apt-get install iptables iproute

Finally, the following are often useful for testing and debugging:

  # apt-get install wireshark tshark socat

Once the dependencies are installed, build the project.

  $ mkdir tcpr-build
  $ cd tcpr-build
  $ ../tcpr/configure && make

The packet filter program, `tcpr-filter', requires some special privileges
to run.

  # setcap cap_net_admin,cap_net_raw,cap_sys_nice+eip tcpr-filter

Whenever you rebuild tcpr-filter, the overwritten file will lose its
capabilities and you will need to set them again.  However, you will be
able to run the filter as an unprivileged user.

The `tcpr-chat' program can run as an application or its peer, with either
endpoint initiating the connection.  Both endpoints pipe their standard
input and output through the network connection.  The distribution
includes a script to install appropriate rules in the firewall.

  # tcpr-setup-iptables

Now run the filter.

  $ tcpr-filter

In its own terminal, run the peer as a server.

  $ tcpr-chat -P

In yet another terminal, run the application as a client.

  $ tcpr-chat

Now chat back and forth between the two endpoints.  You can kill the
fault-tolerant application with control-C.  You can then recover by
running the application again as the client.

  $ tcpr-chat

You can also kill and recover the filter in the same way, or even kill
both and recover them simultaneously.  When you are finished at either
endpoint, type control-D.  When both ends have finished, they will exit.
Finally, kill the filter.

The setup script has replaced the firewall's original configuration,
but saved it in a file in the working directory.  To clean up when you
are finished, there is a script to restore the firewall.

  # tcpr-restore-iptables

To get a closer look at what is happening during a demonstration,
or to debug a problem, you can run the filter with the `-l' option,
which causes it to dump packet traces from both internal and external
perspectives.  It can also be useful to set up another terminal to
watch the state various connections are in with `netstat'.

Another useful utility is `tcpr-control', which prints out a
human-readable representation of TCPR's state for the connection, and can
also be used to manipulate state on behalf of a broken or non-TCPR-aware
application.  If the application crashes but you move on to something
else without recovering and closing gracefully, its old state might
confuse the application into recovering when you mean to establish a
fresh connection; you can remove it with `tcpr-control -D'.

The final program is `tcpr-benchmark', which connects to a peer's echo
service and deliberately fails and recovers many connections in order
to benchmark recovery time.  Other benchmarks, such as throughput and
latency, can be measured using `tcpr-chat' and inspecting packet traces
using Wireshark.

To write new applications, look through `src/chat.c' in detail.  It is
useful not only for demonstrating the system to others, but also for
demonstrating by example how to write a TCPR-aware application.
