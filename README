The goal of this document is to get a new user or developer of TCPR
up to speed, from cloning the repository to using the unit tests and
demonstration application.


INSTALLATION

TCPR builds with the standard GNU autotools.  However, the repository
does not contain any generated files, so immediately after cloning it
is necessary to set up some infrastructure by running `autoreconf -i'.

The filter depends on the `libnfnetlink' and `libnetfilter_queue'
libraries and development headers, which can be installed on an Ubuntu
machine with:

  # apt-get install libnetfilter-queue-dev

Other programs and packages useful for the following examples, or debugging,
include:

  iptables
  iproute2
  wireshark
  tshark
  socat
  openvpn

Once set up, the usual `./configure && make' incantation will build TCPR,
resulting in three programs:

  tcpr-netfilter    the actual packet filter
  tcpr-application  the demonstration chat application
  tcpr-test         the unit tests

As usual, `make install' should put the programs in our PATH, and `make
uninstall' removes them again.


FILTER OVERVIEW

For a particular application, which might consist of many replicas,
one instance of the packet filter is deployed such that any TCP packet
the application sends or receives must flow through it; the recommended
approach is to run them on the same machine.  The application is bound
to an `internal' address, which the filter translates to an `external'
address for the benefit of the application's peers.  The peers must be
bound to addresses different from the application's external address,
because it is used to distinguish packet directions.

In addition to normal TCP traffic, the application and filter also
communicate directly over UDP, at pre-configured ports.  For this purpose,
the application is bound to the internal address and the filter is bound
to the external address.

Thus, the filter needs four pieces of information: the internal and
external addresses, and the internal (application) and external (filter)
ports for out-of-band communication.


EXAMPLE: LOCAL DEMONSTRATION

The demonstration application, `tcpr-application', is able to function as
a as a client or a server; once a connection is established, it simply
bridges its standard input and output with the connection, enabling a
sort of `chat' demonstration.

For a working example, let us step through using the demonstration
program over the loopback device on a single machine.  The peer will use
the standard loopback address, 127.0.0.1, and in order to have distinct
addresses for the application and the filter (internal and external),
we will arbitrarily establish two more:

  # ip addr add dev lo 127.0.0.2/32
  # ip addr add dev lo 127.0.0.3/32

To double check, we can list the current addresses with `ip addr'.  Later,
we can remove these addresses by repeating the above commands with `del'
instead of `add'.

Now it is necessary to configure the Linux builtin firewall, Netfilter, to
capture the appropriate packets and send them to userspace for the filter:

  # iptables -A OUTPUT -s 127.0.0.3 -j NFQUEUE
  # iptables -A INPUT -d 127.0.0.2 -j NFQUEUE

To double check, we can list the current rules with `iptables -L -n'.
Later, we can remove these rules by repeating the above commands with
`-D' instead of `-A', or run `iptables -F' to remove all rules.

Now we can run the filter, configuring the internal and external addresses
and ports with the `-i' and `-e' options:

  # tcpr-netfilter -e 127.0.0.2:6666 -i 127.0.0.3:7777 &

Now we run the application as a server, listening for a connection to
its external address at port 8888:

  $ tcpr-application -e 127.0.0.2:6666 -i 127.0.0.3:7777 -l 8888

In another terminal, we run the peer:

  $ socat -t 60 tcp:127.0.0.2:8888,bind=127.0.0.1,reuseaddr -

Now the two programs can talk back and forth in a line-oriented manner.
We can kill the filter with `pkill tcpr-netfilter', run it again, and
it will recover; similarly we can kill the application with control-C,
run it again, and it will recover; we can also kill and recover both at
the same time.

To get a closer look at what is happening, or to debug a problem,
we can run the filter with the `-d' option, which causes it to dump
packet traces from both internal and external perspectives, along with
per-packet snapshots of its internal state for the connection.  It can
also be useful to watch what state the various connections are in:

  $ watch 'netstat -n | grep 127\\.'

When finished, we can close the connection by typing control-D at
each end.  We can then establish a new connection using the same ports
right away.


EXAMPLE: UNIT TESTS

The unit test program, `tcpr-test', employs a tunnel device in order
to appear to be an entire network of separate machines, from which it
plays the role of both application and peer and runs the filter through
its paces.  First, the tunnel device must be created:

  # openvpn --mktun --dev tcpr-test --dev-type tun

We can also pass the `--user' option to establish a non-root user who can
run the test.  To double check, we can run `ip link' to see the current
devices.  Later, we can remove the device by repeating the above command
with `--rmtun' instead of `--mktun'.  Once the device exists, we must turn
it on, establish its address, and set up the appropriate firewall rules:

  # ip link set tcpr-test up
  # ip addr add 10.10.10.1/24 dev tcpr-test
  # iptables -A FORWARD -s 10.10.10.1/24 -j NFQUEUE

Finally, we must configure the kernel to route packets and not complain:

  # echo 0 | tee /proc/sys/net/ipv4/conf/*/send_redirects > /dev/null
  # echo 1 | tee /proc/sys/net/ipv4/ip_forward > /dev/null

Once set up, we run the filter with the following options:

  # tcpr-netfilter -i 10.10.10.4:6666 -e 10.10.10.3:7777 &

And, last but not least, the test:

  # tcpr-test

The test cleans up after itself, so it can be run multiple times without
restarting the filter.


WRITING NEW APPLICATIONS

Look through `tcpr-application.c' in detail.  It is useful not only
for demonstrating the system to others, but also for demonstrating by
example how to write a TCPR-aware application.


Go forth and protect TCP!
